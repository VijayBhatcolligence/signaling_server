<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloudflare WebRTC Multi-User</title>
    <style>
        /* General Styles */
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
        }

        h1, h2 {
            color: #333;
            text-align: center;
        }

        /* Local Video Styles */
        #localVideo {
            width: 320px;
            height: 240px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        /* Call Controls Styles */
        .call-controls {
            display: flex;
            justify-content: center;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .call-control-button {
            padding: 10px 15px;
            margin: 0 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            font-size: 16px;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .call-control-button:hover {
            background-color: #0056b3;
        }

        .call-control-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            color: #666;
            box-shadow: none;
        }

        /* Remote Videos Styles */
        #remoteVideos {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        #remoteVideos video {
            width: 320px;
            height: 240px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin: 10px;
            object-fit: cover; /* Prevents distortion */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            animation: fadeIn 0.5s ease;
        }

        /* Fade-in animation */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <h1>Cloudflare WebRTC Multi-User Video Call</h1>

    <h2>Local Video</h2>
    <video id="localVideo" autoplay muted playsinline></video>
    <p>Client ID: <span id="localClientId"></span></p>
    <p>Session ID: <span id="localSessionId"></span></p>
    <p>Track ID 1: <span id="localTrackId"></span></p>
    <p>Track ID 2: <span id="localTrackId1"></span></p>

    <!-- Call Controls -->
    <div class="call-controls">
        <button class="call-control-button" id="toggleAudio">Toggle Audio</button>
        <button class="call-control-button" id="toggleVideo">Toggle Video</button>
        <button class="call-control-button" id="hangUp">Hang Up</button>
    </div>

    <h2>Remote Videos</h2>
    <div id="remoteVideos"></div>

    <script>
        const ws = new WebSocket('ws://localhost:3000'); // WebSocket connection
        let clientId;
        let sessionId;
        let transceivers = [];
        const ROOM_ID = "default-room";
        let remoteAnswer = "";  // Store remote answer for debugging
        let isIceGatheringComplete = false; // Track ICE gathering status
        let localStream; // Store the local stream

        const peerConnection = new RTCPeerConnection({
            iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }]
        });

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log(`[Client] ❄️ ICE Candidate:`, event.candidate);
            }
        };

        peerConnection.oniceconnectionstatechange = () => {
            console.log(`[Client] 🔄 ICE Connection State:`, peerConnection.iceConnectionState);
        };

        peerConnection.onconnectionstatechange = () => {
            console.log(`[Client] 🔄 Connection State:`, peerConnection.connectionState);
        };

        peerConnection.onicegatheringstatechange = () => {
            console.log(`[Client] 🔄 ICE Gathering State:`, peerConnection.iceGatheringState);
            if (peerConnection.iceGatheringState === 'complete') {
                console.log("[Client] ✅ ICE Gathering complete.");
                isIceGatheringComplete = true;
            }
        };

        const remoteStreams = new Map(); // Store streamId: video element

        peerConnection.ontrack = (event) => {
            console.log(`[Client] 📡 Received remote track:`, event.track);
            const stream = event.streams[0]; // Get the MediaStream
            if (!stream) {
                console.warn("[Client] ⚠️ No stream found for track.");
                return; // Exit if no stream
            }

            const streamId = stream.id; // Use stream ID as the key

            // Check if a video element already exists for this stream
            let remoteVideo = remoteStreams.get(streamId);

            if (!remoteVideo) {
                // Create a new video element if it doesn't exist
                remoteVideo = document.createElement('video');
                remoteVideo.id = `video-${streamId}`; // Use streamId in the ID
                remoteVideo.autoplay = true;
                remoteVideo.playsInline = true;
                if(event.track.kind="audio"){
                    remoteVideo.style.display="none";
                }
                document.getElementById('remoteVideos').appendChild(remoteVideo);

                // Apply fade-in animation
                remoteVideo.classList.add('fade-in');

                // Store the video element in the map
                remoteStreams.set(streamId, remoteVideo);
            }

            // Set the srcObject to the stream (only set once)
            remoteVideo.srcObject = stream; // Ensure srcObject is assigned

            console.log(`[Client] ✅ Remote video updated for stream: ${streamId}`);


            remoteVideo.addEventListener('loadedmetadata', () => {
                remoteVideo.play().catch(error => {
                    console.error("Playback failed:", error);
                });
            });
        };



        ws.addEventListener('open', () => {
            console.log('[Client] ✅ WebSocket connected');
            clientId = generateClientId();
            document.getElementById('localClientId').textContent = clientId;
            startWebRTC();
        });

        ws.addEventListener('message', async (event) => {
            const message = JSON.parse(event.data);


            if (message.type === 'trackAdded') {
                sessionId = message.sessionId;
                const trackId = message.response.tracks[0]?.trackName || "N/A";
                const trackId1 = message.response.tracks[1]?.trackName || "N/A";

                document.getElementById('localSessionId').textContent = sessionId;
                document.getElementById('localTrackId').textContent = trackId;
                document.getElementById('localTrackId1').textContent = trackId1;
                console.log(`[Client] 🔑 Cloudflare session created: ${sessionId}, Track1: ${trackId}, Track2: ${trackId1}`);
                console.log(message.response.sessionDescription.sdp);

            } else if (message.type === 'remoteClientConnected') {
                handleRemoteClient(message);

            }


            if (message.type === 'trackAdded') {
                console.log(peerConnection);
                console.log(`[Client] 🔗 Created PeerConnection for ${clientId}`);
                console.log(`[Client] 🔄 Received Answer from SFU, setting remote description...`);
                try {
                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(message.response.sessionDescription)
                    );
                    console.log(`[Client] ✅ Remote Description set`);
                } catch (error) {
                    console.error(`[Client] ❌ Error setting remote description:`, error);
                }

            } else if (message.type === 'pullTracksResponse') {
                console.log("[Client] 📡 Tracks pulled successfully:", message.data);

                // Delay renegotiation slightly to ensure remote side is ready.
                setTimeout(async () => {

                    try {
                        console.log(`[Client] 🔄 Setting remote description with pullTracksResponse`);

                        await peerConnection.setRemoteDescription(
                            new RTCSessionDescription(message.data.sessionDescription)
                        );
                        console.log(`[Client] ✅ Remote Description set from pullTracksResponse`);

                        console.log(`[Client] 🔄 Creating answer...`);
                        remoteAnswer = await peerConnection.createAnswer(); // Store for debugging
                        console.log("Created remote answer:", remoteAnswer);


                        console.log(`[Client] 🔄 Setting local description with remote answer...`);
                        await peerConnection.setLocalDescription(remoteAnswer);

                        ws.send(JSON.stringify({
                            type: "renegotiate",
                            clientid: sessionId,
                            sessionDescription: {
                                sdp: peerConnection.localDescription.sdp, // Use the updated local description
                                type: "answer"
                            }
                        }));

                    } catch (error) {
                        console.error(`[Client] ❌ Error during renegotiation:`, error);
                    }
                }, 500); // Adjust delay as needed.  Experiment with longer times.

            } else if (message.type === 'error') {
                console.error(`[Client] ❌ Server Error: ${message.message}`);
            }
            if (message.type == 'renegotiateResponse') {
                console.log(message, "renegotiate response");
            }

        });

        async function startWebRTC() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true }); // Assign to global variable
                document.getElementById('localVideo').srcObject = localStream;
                console.log(`[Client] 🎥 Local stream active.`, localStream);



                transceivers = localStream.getTracks().map(track =>
                    peerConnection.addTransceiver(track, { direction: "sendrecv" })
                );

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                const trackData = {
                    sessionDescription: { type: "offer", sdp: peerConnection.localDescription.sdp },
                    tracks: transceivers.map(({ mid, sender }) => ({
                        location: "local",
                        mid,
                        trackName: sender.track?.id || `track-${Date.now()}`
                    }))
                };

                console.log(trackData);

                ws.send(JSON.stringify({
                    type: 'joinCall',
                    clientId: clientId,
                    trackData: trackData,
                    roomId: ROOM_ID
                }));

            } catch (error) {
                console.error(`[Client] ❌ Error:`, error);
            }
        }

        function handleRemoteClient(message) {
            const remoteClientId = message.clientId;
            const remoteSessionId = message.sessionId;
            const trackName = message.trackData.tracks[0]?.trackName || "N/A";
            const trackName1 = message.trackData.tracks[1]?.trackName || "N/A";

            console.log(`[Client] 🧑‍🤝‍🧑 New Remote Client: ${remoteClientId}, Session: ${remoteSessionId}, Track1: ${trackName}, Track2: ${trackName1}`);

            setTimeout(() => {
                console.log("[Client] 🔄 Pulling tracks from Calls API...");

                if (transceivers.length === 0) {
                    console.error("[Client] ❌ No transceivers available!");
                    return;
                }

                const trackData = message?.trackData?.tracks?.map(track => ({
    location: "remote",  // Always set to "remote" for received tracks
    trackName: track?.trackName || "unknown",
    sessionId: remoteSessionId, // Ensure remoteSessionId is defined
    mid: track?.mid || `#${track?.trackName}`, // mid associated with transceiver
    bidirectionalMediaStream: track?.bidirectionalMediaStream || true, // Default to false
    kind: track?.kind || "video" // Default kind, change if needed
})) || [];

                ws.send(JSON.stringify({
                    type: "pullTracks",
                    sessionId: sessionId,
                    body: { tracks: trackData }
                }));
            }, 1000);
        }

        function generateClientId() {
            return Math.random().toString(36).substring(2, 15);
        }

        // Call Control Functions
        function toggleAudio() {
            if (!localStream) return;
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                console.log(`[Client] 🎤 Audio ${audioTrack.enabled ? 'enabled' : 'disabled'}`);
            }
        }

        function toggleVideo() {
            if (!localStream) return;
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                console.log(`[Client] 🎥 Video ${videoTrack.enabled ? 'enabled' : 'disabled'}`);
                document.getElementById('localVideo').style.display = videoTrack.enabled ? 'block' : 'none';
            }
        }

        function hangUp() {
            console.log("[Client] 📞 Hanging up call");

            // Disable call control buttons
            document.getElementById('toggleAudio').disabled = true;
            document.getElementById('toggleVideo').disabled = true;
            document.getElementById('hangUp').disabled = true;

            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                document.getElementById('localVideo').srcObject = null;
            }

            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
            }

            // Clean up remote videos
            const remoteVideos = document.getElementById('remoteVideos');
            while (remoteVideos.firstChild) {
                remoteVideos.removeChild(remoteVideos.firstChild);
            }

            // Optionally, notify the server to end the session
            ws.send(JSON.stringify({ type: 'hangUp', sessionId: sessionId, clientId: clientId }));
        }

        // Event Listeners for Call Controls
        document.getElementById('toggleAudio').addEventListener('click', toggleAudio);
        document.getElementById('toggleVideo').addEventListener('click', toggleVideo);
        document.getElementById('hangUp').addEventListener('click', hangUp);

    </script>
</body>
</html>