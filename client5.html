<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloudflare WebRTC Multi-User</title>
</head>
<body>
    <h1>Cloudflare WebRTC Multi-User Video Call</h1>

    <h2>Local Video</h2>
    <video id="localVideo" autoplay muted playsinline></video>
    <p>Client ID: <span id="localClientId"></span></p>
    <p>Session ID: <span id="localSessionId"></span></p>
    <p>Track ID 1: <span id="localTrackId"></span></p>
    <p>Track ID 2: <span id="localTrackId1"></span></p>

    <h2>Remote Videos</h2>
    <div id="remoteVideos"></div>

    <script>
        const ws = new WebSocket('ws://localhost:3000'); // WebSocket connection
        let clientId;
        let sessionId;
        let transceivers = []; 
        const ROOM_ID = "default-room";
        const peerConnection = new RTCPeerConnection({
            iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }]
        });

        ws.addEventListener('open', () => {
            console.log('[Client] ✅ WebSocket connected');
            clientId = generateClientId();
            document.getElementById('localClientId').textContent = clientId;
            startWebRTC();
        });

        ws.addEventListener('message', async (event) => {
            const message = JSON.parse(event.data);
            console.log(`[Client] ⬇️ Received: ${message.type}`, message);

            if (message.type === 'trackAdded') {
                sessionId = message.sessionId;
                const trackId = message.response.tracks[0]?.trackName || "N/A";
                const trackId1 = message.response.tracks[1]?.trackName || "N/A";

                document.getElementById('localSessionId').textContent = sessionId;
                document.getElementById('localTrackId').textContent = trackId;
                document.getElementById('localTrackId1').textContent = trackId1;
                console.log(`[Client] 🔑 Cloudflare session created: ${sessionId}, Track1: ${trackId}, Track2: ${trackId1}`);

            }  

            if (message.type === 'remoteClientConnected') {
                handleRemoteClient(message);
            } 

            if (message.type === 'trackAdded') {
                console.log(peerConnection);
                console.log("Local tracks being sent:", peerConnection.getSenders().map(s => s.track));

                console.log(`[Client] 🔄 Received Answer from SFU, setting remote description...`);

                try {
                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(message.response.sessionDescription)
                    );
                    console.log(`[Client] ✅ Remote Description set`);
                    
                    checkSFUUsage(peerConnection); // Check if SFU is used
                     // Check outbound track stats
                } catch (error) {
                    console.error(` ❌ Error setting remote description:`, error);
                }
            } 
            
            if (message.type === 'pullTracksResponse') {
                console.log("[Client] 📡 Tracks pulled successfully:", message.data);

                try {
                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(message.data.sessionDescription)
                    );
                    console.log(`[Client] ✅ Remote Description set`);

                    console.log(`[Client] 🔄 Creating answer...`);
                    remoteAnswer = await peerConnection.createAnswer();
                    console.log("Created remote answer:", remoteAnswer);

                    ws.send(JSON.stringify({
                        type: "renegotiate",
                        clientid: sessionId,
                        sessionDescription: {
                            sdp: remoteAnswer.sdp, 
                            type: "answer"
                        }
                    }));

                } catch (error) {
                    console.error(`[Client] ❌ Error setting remote description:`, error);
                }
            }
        });

        async function startWebRTC() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                document.getElementById('localVideo').srcObject = stream;
                console.log(`[Client] 🎥 Local stream active.`, stream);

                transceivers = stream.getTracks().map(track =>
                    peerConnection.addTransceiver(track, { direction: "sendrecv" })
                );

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                const trackData = {
                    sessionDescription: { type: "offer", sdp: peerConnection.localDescription.sdp },
                    tracks: transceivers.map(({ mid, sender }) => ({
                        location: "local",
                        mid,
                        trackName: sender.track?.id || `track-${Date.now()}`
                    }))
                };

                ws.send(JSON.stringify({
                    type: 'joinCall',
                    clientId: clientId,
                    trackData: trackData,
                    roomId: ROOM_ID
                }));

            } catch (error) {
                console.error(`[Client] ❌ Error:`, error);
            }
        }

        function handleRemoteClient(message) {
            console.log(`[Client] 🧑‍🤝‍🧑 New Remote Client: ${message.clientId}`);

            setTimeout(() => {
                console.log("[Client] 🔄 Pulling tracks from Calls API...");
                
                if (transceivers.length === 0) {
                    console.error("[Client] ❌ No transceivers available!");
                    return;
                }

                ws.send(JSON.stringify({
                    type: "pullTracks",
                    sessionId: message.sessionId,
                    body: { tracks: message.trackData.tracks }
                }));
            }, 1000);
        }

        function generateClientId() {
            return Math.random().toString(36).substring(2, 15);
        }

        // Function to check if SFU is used
        async function checkSFUUsage(peerConnection) {
            const stats = await peerConnection.getStats();
            let isUsingSFU = false;

            stats.forEach(report => {
                if (report.type === "candidate-pair" && report.state === "succeeded") {
                    if (report.relayProtocol) {
                        console.log(`🟠 SFU Detected! Media is relayed via: ${report.relayProtocol}`);
                        isUsingSFU = true;
                    } else {
                        console.log("🟢 Direct P2P connection, SFU not involved.");
                    }
                }
            });

            return isUsingSFU;
        }

        // Function to check outbound track stats
        function startOutboundStatsMonitoring(peerConnection) {
    setInterval(async () => {
        const stats = await peerConnection.getStats();
        stats.forEach(report => {
            if (report.type === "outbound-rtp" && report.kind === "video") {
                console.log(`🟢 Outbound Video - Packets Sent: ${report.packetsSent}, Bytes Sent: ${report.bytesSent}`);
            }
            if (report.type === "outbound-rtp" && report.kind === "audio") {
                console.log(`🟢 Outbound Audio - Packets Sent: ${report.packetsSent}, Bytes Sent: ${report.bytesSent}`);
            }
        });
    }, 100000); // Updates stats every second
}

// Call this function after peer connection is established
peerConnection.oniceconnectionstatechange = () => {
    if (peerConnection.iceConnectionState === "connected") {
        console.log("[Client] ✅ PeerConnection established. Monitoring outbound track stats...");
        startOutboundStatsMonitoring(peerConnection);
    }
};


        // Listen for remote tracks
        peerConnection.ontrack = (event) => {
            console.log(`📡 Received remote track:`, event.track);
            const remoteVideo = document.createElement('video');
            remoteVideo.srcObject = event.streams[0];
            remoteVideo.autoplay = true;
            remoteVideo.playsInline = true;
            document.getElementById("remoteVideos").appendChild(remoteVideo);
        };
    </script>
</body>
</html>
